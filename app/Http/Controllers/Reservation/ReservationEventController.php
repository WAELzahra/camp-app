<?php

namespace App\Http\Controllers\Reservation;

use App\Models\Reservations_events;
use App\Models\Events;
use App\Models\Payments;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
use App\Mail\ReservationStatusUpdated;
use Carbon\Carbon;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Validator;
use Symfony\Component\HttpFoundation\StreamedResponse;
use App\Http\Controllers\Controller;



class ReservationEventController extends Controller
{
    /**
     * Lister les participants d'un √©v√©nement avec option de filtrage par statut.
     */
    public function participants($eventId, Request $request)
    {
        $event = Events::find($eventId);
        if (!$event) {
            return response()->json(['message' => '√âv√©nement non trouv√©'], 404);
        }

        $status = $request->query('status');

        $query = Reservations_events::with('user')->where('event_id', $eventId);

        if ($status) {
            $query->where('status', $status);
        }

        $participants = $query->get();

        return response()->json([
            'event_id' => $eventId,
            'event_title' => $event->title,
            'participants' => $participants,
        ]);
    }

    /**
     * Statistiques du nombre de participants par statut pour un √©v√©nement.
     */
    public function participantStats($eventId)
    {
        $event = Events::find($eventId);
        if (!$event) {
            return response()->json(['message' => '√âv√©nement non trouv√©'], 404);
        }

        $stats = Reservations_events::where('event_id', $eventId)
            ->select('status', \DB::raw('count(*) as total'))
            ->groupBy('status')
            ->get();

        return response()->json([
            'event_id' => $eventId,
            'event_title' => $event->title,
            'stats' => $stats,
        ]);
    }

    /**
     * Ajouter manuellement un participant √† un √©v√©nement.
     */
    public function addManualParticipant(Request $request, $eventId)
    {
        $request->validate([
            'name' => 'required|string',
            'email' => 'nullable|email',
            'phone' => 'nullable|string',
            'nbr_place' => 'required|integer|min:1',
        ]);

        $event = Events::findOrFail($eventId);

        if ($event->nbr_place_restante < $request->nbr_place) {
            return response()->json(['message' => 'Nombre de places insuffisant pour cet √©v√©nement.'], 400);
        }

        $reservation = Reservations_events::create([
            'event_id' => $eventId,
            'group_id' => auth()->id(),
            'name' => $request->name,
            'email' => $request->email,
            'phone' => $request->phone,
            'nbr_place' => $request->nbr_place,
            'status' => 'confirm√©',
            'created_by' => auth()->id(),
        ]);

        $event->nbr_place_restante -= $request->nbr_place;
        $event->save();

        return response()->json([
            'message' => 'Participant ajout√© avec succ√®s.',
            'data' => $reservation,
        ]);
    }

    /**
     * Supprimer une r√©servation/participant.
     */
    public function destroy($reservationId)
    {
        $reservation = Reservations_events::find($reservationId);

        if (!$reservation) {
            return response()->json(['message' => 'R√©servation introuvable'], 404);
        }

        $reservation->delete();

        return response()->json(['message' => 'R√©servation supprim√©e avec succ√®s']);
    }

    /**
     * Recherche avanc√©e de participants sur un √©v√©nement.
     */
    public function search(Request $request, $eventId)
    {
        $query = Reservations_events::where('event_id', $eventId);

        if ($request->filled('status')) {
            $query->where('status', $request->status);
        }
        if ($request->filled('name')) {
            $query->where('name', 'like', '%' . $request->name . '%');
        }
        if ($request->filled('phone')) {
            $query->where('phone', 'like', '%' . $request->phone . '%');
        }
        if ($request->filled('email')) {
            $query->where('email', 'like', '%' . $request->email . '%');
        }

        $results = $query->get();

        if ($results->isEmpty()) {
            return response()->json([
                'message' => 'Aucun participant trouv√© pour cet √©v√©nement avec les crit√®res sp√©cifi√©s.'
            ], 404);
        }

        return response()->json($results);
    }

    /**
     * Mettre √† jour un participant ajout√© manuellement, avec gestion des places.
     */
public function updateManualParticipant(Request $request, $reservationId)
{
    $reservation = Reservations_events::findOrFail($reservationId);

    if ($reservation->created_by !== auth()->id()) {
        return response()->json(['message' => 'Non autoris√© √† modifier ce participant.'], 403);
    }

    // R√©cup√©rer les donn√©es JSON brutes
    $data = $request->json()->all();

    if (empty($data)) {
        return response()->json(['message' => 'Aucune donn√©e re√ßue pour la mise √† jour.'], 400);
    }

    // Valider uniquement les champs pr√©sents
    $rules = [
        'name' => 'sometimes|string',
        'email' => 'sometimes|email',
        'phone' => 'sometimes|string',
        'nbr_place' => 'sometimes|integer|min:1',
    ];

    $validator = \Validator::make($data, $rules);

    if ($validator->fails()) {
        return response()->json(['errors' => $validator->errors()], 422);
    }

    // Construire le tableau des champs √† mettre √† jour
    $dataToUpdate = [];

    foreach (['name', 'email', 'phone', 'nbr_place'] as $field) {
        if (array_key_exists($field, $data)) {
            $dataToUpdate[$field] = $data[$field];
        }
    }

    if (empty($dataToUpdate)) {
        return response()->json(['message' => 'Aucune donn√©e √† mettre √† jour.'], 400);
    }

    // Si nbr_place est modifi√©, v√©rifier la disponibilit√© des places restantes
    if (isset($dataToUpdate['nbr_place'])) {
        $diff = $dataToUpdate['nbr_place'] - $reservation->nbr_place;
        $event = Events::findOrFail($reservation->event_id);

        if ($diff > 0 && $event->nbr_place_restante < $diff) {
            return response()->json(['message' => 'Pas assez de places disponibles.'], 400);
        }

        $event->nbr_place_restante -= $diff;
        $event->save();
    }

    // Mise √† jour en base
    $reservation->update($dataToUpdate);

    return response()->json([
        'message' => 'Participant mis √† jour avec succ√®s.',
        'participant' => $reservation->fresh(),
    ]);
}


    /**
     * Cr√©er une r√©servation avec paiement (int√©gration √† compl√©ter).
     * Cr√©er une r√©servation avec le statut "en_attente_paiement".
     */
    public function createReservationWithPayment(Request $request)
    {
        $request->validate([
            'event_id' => 'required|exists:events,id',
            'nbr_place' => 'required|integer|min:1',
            'group_id' => 'required|exists:users,id',
        ]);

        $user = auth()->user();

        $reservation = Reservations_events::create([
            'user_id' => $user->id,
            'group_id' => $request->group_id,
            'event_id' => $request->event_id,
            'name' => $user->name,
            'email' => $user->email,
            'phone' => $user->phone,
            'nbr_place' => $request->nbr_place,
            'status' => 'en_attente_paiement',
            'created_by' => $user->id,
        ]);

        return response()->json([
            'message' => 'R√©servation cr√©√©e en attente de paiement.',
            'reservation' => $reservation,
        ], 201);
    }

    /**
     * Afficher une r√©servation avec ses d√©tails.
     */
    public function show($reservationId)
    {
        $reservation = Reservations_events::with('event')->findOrFail($reservationId);

        return response()->json($reservation);
    }

    public function toutesMesReservations(Request $request)
{
    $user = Auth::user();

    $query = Reservations_events::where('group_id', $user->id)
        ->with(['event', 'user', 'payment']);

    // üîç Filtres dynamiques
    if ($request->filled('status')) {
        $query->where('status', $request->status);
    }

    if ($request->filled('name')) {
        $query->where('name', 'like', '%' . $request->name . '%');
    }

    if ($request->filled('email')) {
        $query->where('email', 'like', '%' . $request->email . '%');
    }

    if ($request->filled('phone')) {
        $query->where('phone', 'like', '%' . $request->phone . '%');
    }

    if ($request->filled('from')) {
        $query->whereDate('created_at', '>=', $request->from);
    }

    if ($request->filled('to')) {
        $query->whereDate('created_at', '<=', $request->to);
    }

    // üîÑ R√©cup√©ration des donn√©es pagin√©es
    $reservations = $query->orderBy('created_at', 'desc')->paginate(10);

    // ‚úÖ V√©rification si vide
    if ($reservations->isEmpty()) {
        return response()->json([
            'message' => 'Aucune r√©servation trouv√©e.'
        ], 200); // ou 204 si tu pr√©f√®res
    }

    return response()->json($reservations);
}

    public function reservationsParEvenement($event_id)
    {
        $user = Auth::user();

        $reservations = Reservations_events::where('group_id', $user->id)
            ->where('event_id', $event_id)
            ->with(['user', 'payment'])
            ->orderByDesc('created_at')
            ->get();

        if ($reservations->isEmpty()) {
            return response()->json(['message' => 'Aucune r√©servation trouv√©e pour cet √©v√©nement.'], 200);
        }

        return response()->json($reservations);
    }

    // Export des r√©servations (CSV)
    public function exportReservations(Request $request)
    {
        $user = Auth::user();

        $reservations = Reservations_events::where('group_id', $user->id)->with(['event'])->get();

        if ($reservations->isEmpty()) {
            return response()->json(['message' => 'Aucune r√©servation √† exporter.'], 200);
        }

        $csvData = [];
        $csvData[] = ["Nom", "Email", "T√©l√©phone", "√âv√©nement", "Statut", "Places", "Date"];

        foreach ($reservations as $r) {
            $csvData[] = [
                $r->name,
                $r->email,
                $r->phone,
                optional($r->event)->title,
                $r->status,
                $r->nbr_place,
                $r->created_at,
            ];
        }

        $filename = 'reservations_export_' . now()->timestamp . '.csv';
        $handle = fopen(storage_path("app/$filename"), 'w');
        foreach ($csvData as $row) {
            fputcsv($handle, $row);
        }
        fclose($handle);

        return response()->download(storage_path("app/$filename"))->deleteFileAfterSend(true);
    }

    //  Mise √† jour du statut (confirm√©/refus√©)
    public function updateStatus(Request $request, $id)
{
    $reservation = Reservations_events::findOrFail($id);

    if ($reservation->group_id !== Auth::id()) {
        return response()->json(['message' => 'Non autoris√©.'], 403);
    }

    // R√©cup√©rer les donn√©es JSON brutes
    $data = $request->json()->all();

    // Valider √† partir de $data
    $validator = \Validator::make($data, [
        'status' => 'required|in:confirm√©,refus√©,en_attente,annul√©'
    ]);

    if ($validator->fails()) {
        return response()->json(['errors' => $validator->errors(), 'message' => 'Validation √©chou√©e.'], 422);
    }

    // Mise √† jour
    $reservation->status = $data['status'];
    $reservation->save();

    return response()->json(['message' => 'Statut mis √† jour avec succ√®s.']);
}


    // Annulation avec remboursement
    // Annuler une r√©servation et d√©clencher un remboursement.
    
    public function cancelReservation($id)
    {
        $reservation = Reservations_events::with('payment')->findOrFail($id);

        if ($reservation->group_id !== Auth::id()) {
            return response()->json(['message' => 'Non autoris√©.'], 403);
        }

        // Exemple : appel API remboursement Flouci ici via $reservation->payment->payment_id

        $reservation->status = 'annul√©';
        $reservation->save();

        return response()->json(['message' => 'R√©servation annul√©e et remboursement lanc√©.']);
    }

    //  Modifier le nombre de places
    public function updatePlaces(Request $request, $id)
{
    $data = $request->json()->all();

    $validator = \Validator::make($data, [
        'nbr_place' => 'required|integer|min:1'
    ]);

    if ($validator->fails()) {
        return response()->json(['message' => 'Erreur de validation.', 'errors' => $validator->errors()], 422);
    }

    $reservation = Reservations_events::findOrFail($id);

    if ($reservation->group_id !== Auth::id()) {
        return response()->json(['message' => 'Non autoris√©.'], 403);
    }

    $event = Events::findOrFail($reservation->event_id);

    $ancienne_place = $reservation->nbr_place;
    $nouvelle_place = $data['nbr_place'];
    $diff = $nouvelle_place - $ancienne_place;

    // V√©rifier si assez de places restantes si on augmente
    if ($diff > 0 && $event->nbr_place_restante < $diff) {
        return response()->json(['message' => 'Pas assez de places restantes.'], 400);
    }

    // Mettre √† jour le champ `nbr_place_restante`
    $event->nbr_place_restante -= $diff;
    $event->save();

    // Mettre √† jour la r√©servation
    $reservation->nbr_place = $nouvelle_place;
    $reservation->save();

    return response()->json(['message' => 'Nombre de places mis √† jour.']);
}


    // Statistiques de participation
    public function reservationStats()
    {
        $user = Auth::user();

        $total = Reservations_events::where('group_id', $user->id)->count();
        $confirmes = Reservations_events::where('group_id', $user->id)->where('status', 'confirm√©')->count();
        $en_attente = Reservations_events::where('group_id', $user->id)->where('status', 'en_attente')->count();
        $annules = Reservations_events::where('group_id', $user->id)->where('status', 'annul√©')->count();

        return response()->json([
            'total' => $total,
            'confirm√©s' => $confirmes,
            'en_attente' => $en_attente,
            'annul√©s' => $annules,
        ]);
    }


    public function updateReservation(Request $request, $reservationId)
{
    $reservation = Reservations_events::findOrFail($reservationId);

    // V√©rifier que le groupe connect√© est bien propri√©taire de la r√©servation
    if ($reservation->group_id !== Auth::id()) {
        return response()->json(['message' => 'Non autoris√© √† modifier cette r√©servation.'], 403);
    }

    // R√©cup√©rer les donn√©es JSON brutes
    $data = $request->json()->all();

    if (empty($data)) {
        return response()->json(['message' => 'Aucune donn√©e re√ßue pour la mise √† jour.'], 400);
    }

    // D√©finir les r√®gles de validation selon les champs modifiables
    $rules = [
        'status' => 'sometimes|in:confirm√©,refus√©,en_attente,annul√©',
        'nbr_place' => 'sometimes|integer|min:1',
        'name' => 'sometimes|string',
        'email' => 'sometimes|email',
        'phone' => 'sometimes|string',
    ];

    $validator = \Validator::make($data, $rules);

    if ($validator->fails()) {
        return response()->json(['errors' => $validator->errors(), 'message' => 'Validation √©chou√©e.'], 422);
    }

    // Gestion sp√©cifique pour nbr_place : v√©rifier la disponibilit√© des places restantes
    if (isset($data['nbr_place'])) {
        $event = Events::findOrFail($reservation->event_id);
        $diff = $data['nbr_place'] - $reservation->nbr_place;

        if ($diff > 0 && $event->nbr_place_restante < $diff) {
            return response()->json(['message' => 'Pas assez de places disponibles.'], 400);
        }

        // Mettre √† jour nbr_place_restante sur l'√©v√©nement
        $event->nbr_place_restante -= $diff;
        $event->save();
    }

    // Appliquer la mise √† jour sur la r√©servation
    $reservation->fill($data);
    $reservation->save();

    return response()->json([
        'message' => 'R√©servation mise √† jour avec succ√®s.',
        'reservation' => $reservation->fresh(),
    ]);
}

// Afficher mes r√©servations pass√©es
public function mesReservationsPassees(Request $request)
{
    $user = Auth::user();
    $today = now()->toDateString();

    $query = Reservations_events::where('group_id', $user->id)
        ->whereHas('event', function ($q) use ($today) {
            $q->whereDate('date_sortie', '<', $today);
        })
        ->with(['event', 'user', 'payment']);

    $reservations = $query->orderBy('created_at', 'desc')->paginate(10);

    return response()->json($reservations);
}



};
